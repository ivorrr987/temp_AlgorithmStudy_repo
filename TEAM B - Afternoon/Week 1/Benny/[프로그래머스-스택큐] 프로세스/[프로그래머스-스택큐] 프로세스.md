# 프로그래머스
## 고득점 Kit - 스택/큐
### 풀이
프로세스가 대기 큐에 들어가므로 기본적으로 먼저 들어간 프로세스가 우선순위 심사되어야 한다.
때문에 index 0인 원소가 먼저 빠져나가야 하므로 deque를 사용했다. 
(python에서의 deque와 list의 속도 차이: https://wellsw.tistory.com/122)

location에 해당하는 index를 가진 원소의 실행 순서만 궁금하므로 초기의 index 값을 저장할 필요가 있었다. 
index만 저장하는 deque를 따로 만드는 방법도 있고, 그 외의 다른 여러 방법이 있을 수 있겠지만 priorities의 원소들과 index를 tuple로 묶어 한번에 저장하는 방식을 택했다.

q는 (index, priority)의 순서로 각 원소들이 모여있으며 deque로 선언되어있다.
while문에 'q에 원소가 하나 이상 존재할 때'라는 조건을 주고 반복했다. 
1) 처음 원소를 pop한 후 나머지 우선순위들의 최댓값과 비교한다. 만약 최댓값보다 작다면 다시 q의 맨 뒤에 삽입한다.
2) 만약 그렇지 않다면(현재 pop된 우선순위가 가장 값이 크다면) answer를 1 증가시킨다. 만약 그 index가 location과 일치한다면 while 문을 종료시킨다.

### 리뷰
#### 시간복잡도
priorities가 [1,2,3,4,5,6]과 같은 식으로 되어 있다면 기본적으로 while문을 6+5+4+3+2+1번 돌게 된다. (O(n^2))
또 각 while에서 max()를 사용하게 된다. (O(n))
따라서 O(n^3)의 시간복잡도를 가진다. 단 여기서 priorities의 길이는 100이하이므로 연산횟수는 약 1,000,000번 이하가 된다. 
1~5초의 소요시간을 요구하는 문제는 파이썬 기준으로 약 10억번 이하의 연산을 하는 코드를 짜야하므로 이 코드는 통과될 수 있다.

#### 주의해야 할 점
while문 내부에 `if q and temp[1] < max(q, key=lambda x: x[1])[1]`라는 부분을 주목해야 한다.
while문이 시작될 때 `q.popleft()`를 통해 원소를 하나 빼내므로 `if q`라는 조건을 추가하지 않으면 q가 비어있을 경우 runtime error가 발생한다. (비어있는 상태로 max()를 수행할 수 없으므로)